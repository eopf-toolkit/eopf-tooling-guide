---
title: "Access and Analyze EOPF STAC Zarr Data with R"
format: md
execute:
  cache: true
---

```{r setup}
#| echo: false

# To automatically print data frames as tibbles, without having to convert them inline
print.data.frame <- function(x, ...) {
  if (!inherits(x, "tbl_df")) {
    x <- as_tibble(x)
  }
  print(x, ...)
}
```


# Table of Contents

- [Introduction](#introduction)
- [Prerequisites](#prerequisites)
  - [Dependencies](#dependencies)

# Introduction

This tutorial will explore how to access and analyze Zarr data from the [EOPF Sample Service STAC catalog](https://stac.browser.user.eopf.eodc.eu/) programmatically using R.

# Prerequisites

An R environment is required to follow this tutorial, with R version >= 4.1.0. We recommend using either [RStudio](https://posit.co/download/rstudio-desktop/) or [Positron](https://posit.co/products/ide/positron/) (or a cloud computing environment) and making use of [RStudio projects](https://support.posit.co/hc/en-us/articles/200526207-Using-RStudio-Projects) for a self-contained coding environment.

## Dependencies

We will use the `rstac` package (for accessing the STAC catalog) and the `tidyverse` package (for data manipulation) in this tutorial. You can install them directly from CRAN:

```{r install-rstac}
#| eval: false
install.packages("rstac")
install.packages("tidyverse")
```

We will also use the `Rarr` package to read Zarr data. It must be installed from Bioconductor, so first install the `BiocManager` package:

```{r install-BiocManager}
#| eval: false
install.packages("BiocManager")
```

Then, use this package to install `Rarr`:

```{r install-rarr}
#| eval: false
BiocManager::install("Rarr")
```

Finally, load the packages into your environment:

```{r load, message=FALSE}
#| cache: false
library(rstac)
library(tidyverse)
library(Rarr)
```

## Fixes to the `Rarr` package

We will use functions from the `Rarr` package to read and analyze Zarr data. Unfortunately, there is currently a bug in this package, causing it to parse the EOPF Sample Service data URLs incorrectly -- there is a [pull request](https://github.com/grimbough/Rarr/pull/21) open to fix this. In the meantime, we will write our own version of this URL parsing function and use it instead of the one in `Rarr`.

```{r overwrite-url-parsing}
#| cache: false
.url_parse_other <- function(url) {
  parsed_url <- httr::parse_url(url)
  bucket <- gsub(
    x = parsed_url$path, pattern = "^/?([[a-z0-9\\:\\.-]*)/.*",
    replacement = "\\1", ignore.case = TRUE
  )
  object <- gsub(
    x = parsed_url$path, pattern = "^/?([a-z0-9\\:\\.-]*)/(.*)",
    replacement = "\\2", ignore.case = TRUE
  )
  hostname <- paste0(parsed_url$scheme, "://", parsed_url$hostname)

  if (!is.null(parsed_url$port)) {
    hostname <- paste0(hostname, ":", parsed_url$port)
  }

  res <- list(
    bucket = bucket,
    object = object,
    region = "auto",
    hostname = hostname
  )
  return(res)
}

assignInNamespace(".url_parse_other", .url_parse_other, ns = "Rarr")
```

This function overwrites the existing one in `Rarr`, and allows us to continue with the analysis.

If you try to run some of the examples below and receive a timeout error, please ensure that you have run the above code block.

# Accessing Zarr data from the STAC Catalog

The first step of accessing Zarr data is to understand the assets within the EOPF Sample Service STAC catalog. The [first tutorial](TODO) goes into detail on this, so we recommend reviewing it if you have not already.

For the first part of this tutorial, we will be using data from the [Sentinel-2 Level-2A Collection](https://stac.browser.user.eopf.eodc.eu/collections/sentinel-2-l2a). We fetch the "product" asset under a given item, and can look at its URL:

```{r access-stac-product}
item <- stac("https://stac.core.eopf.eodc.eu/") %>%
  collections(collection_id = "sentinel-2-l2a") %>%
  items(feature_id = "S2B_MSIL2A_20250522T125039_N0511_R095_T26TML_20250522T133252") %>%
  get_request()

product <- item %>%
  assets_select(asset_names = "product")

product_url <- product %>%
  assets_url()

product_url
```

The product is the "top level" Zarr asset, which contains the full Zarr product hierarchy. We can use `zarr_overview()` to get an overview of it, setting `as_data_frame` to `TRUE` so that we can see the entries in a data frame instead of printed directly to the console. Each entry is a Zarr array; we remove `product_url` to get a better idea of what each array is.

```{r overview}
zarr_store <- product_url %>%
  zarr_overview(as_data_frame = TRUE) %>%
  mutate(array = str_remove(path, product_url)) %>%
  relocate(array, .before = path)

zarr_store
```

This shows us the path to access the Zarr array, the number of chunks it contains, the type of data, as well as its dimensions and chunking structure. For example, for the `measurements/reflectance/r10m/b02` array:

```{r array-info}
zarr_store %>%
  filter(array == "/measurements/reflectance/r10m/b02") %>%
  select(path, nchunks, dim, chunk_dim) %>%
  as.list()
```

We can also see an overview of individual arrays using `zarr_overview()`. With the default setting (where `as_data_frame` is `FALSE`), this prints information on the array directly to the console, in a more digestible way:

```{r array-overview}
b02_r10m <- zarr_store %>%
  filter(array == "/measurements/reflectance/r10m/b02") %>%
  pull(path)

b02_r10m %>%
  zarr_overview()
```

# Zarr structure

The above overview tells us that the data is two-dimensional, with dimensions 10980 x 10980. Zarr data is split up into _chunks_, which are smaller, independent piece of the larger array. Chunks can be accessed individually, without loading the entire array. In this case, there are 36 chunks in total, with 6 along each of the dimensions, each of size 1830 x 1830.

To read in Zarr data, we use `read_zarr_array()`, and can pass a list to the `index` argument, describing which elements we want to extract, along each dimension. Since this array is two-dimensional, we can think of the dimensions as rows and columns of the data. For example, to select the first 10 rows and the first 5 columns:

```{r read-array-index}
b02_r10m %>%
  read_zarr_array(list(1:10, 1:5))
```

Or, to select rows rows 8425 to 8430 and columns 1 to 5:

```{r read-array-index-2}
b02_r10m %>%
  read_zarr_array(list(8425:8430, 1:5))
```

TODO: Use the info Tom did (https://github.com/eopf-toolkit/eopf-tooling-guide/blob/EOPF-48-tutorial-2/docs/tutorials/stac_zarr/python/eopf_stac_zarr_xarray.md#variables-and-attributes) to describe what these units actually are etc.

With EOPF data, some measurements are available at multiple dimensions. For example, we can see that the B02 spectral band is available at 10m, 20m, and 60m resolution:

```{r b02-resolutions}
b02 <- zarr_store %>%
  filter(str_starts(array, "/measurements/reflectance"), str_ends(array, "b02"))

b02
```

The resolution affects the dimensions of the data; when measurements are taken at a higher resolution, there will be more data. We can see here that there is less data for the 20m resolution than the 10m resolution (recall, its dimensions are 10980 x 10980), and even less for the 60m resolution:

```{r b02-resolutions-dims}
b02 %>%
  filter(array == "/measurements/reflectance/r20m/b02") %>%
  pull(dim)

b02 %>%
  filter(array == "/measurements/reflectance/r60m/b02") %>%
  pull(dim)
```

# WIP ----

Want to look at owi:

```{r}
item <- stac("https://stac.core.eopf.eodc.eu/") %>%
  collections(collection_id = "sentinel-1-l2-ocn") %>%
  items(feature_id = "S1A_IW_OCN__2SDV_20250604T193923_20250604T193948_059501_0762FA_C971") %>%
  get_request()
```


```{r}
owi_asset <- item$assets$owi

owi_asset[["title"]]
```

```{r}
zarr_store <- item %>%
  assets_select(asset_names = "product") %>%
  assets_url() %>%
  zarr_overview(as_data_frame = TRUE)
  
owi <- zarr_store %>%
  filter(str_starts(path, owi_asset$href)) %>%
  mutate(
    variable = str_remove(path, owi_asset$href),
    variable = str_remove(variable, "/")
  ) %>%
  relocate(variable, .before = path)

owi
```

```{r}
owi %>%
  filter(variable == "latitude") %>%
  pull(path) %>%
  zarr_overview()

owi %>%
  filter(variable == "longitude") %>%
  pull(path) %>%
  zarr_overview()
```

Reading data in. These are small and only have one chunk, we can read them in quickly:

```{r}
owi_lat <- owi %>%
  filter(variable == "latitude") %>%
  pull(path) %>%
  read_zarr_array()

owi_lat[1:5, 1:5]

owi_long <- owi %>%
  filter(variable == "longitude") %>%
  pull(path) %>%
  read_zarr_array()

owi_lat[1:5, 1:5]
```

```{r}
owi_wind_direction <- owi %>%
  filter(variable == "wind_direction") %>%
  pull(path) %>%
  read_zarr_array()

owi_wind_direction[1:5, 1:5]
```

Visualisation with stars, first convert to curvilinear grid, common in satellite data.

```{r}
library(stars)

# Assume:
# - owi_dir: matrix of wind direction (167 × 255)
# - owi_long: matrix of longitude (167 × 255)
# - owi_lat: matrix of latitude (167 × 255)

# Step 1: Create stars object with wind data
s <- st_as_stars(wind = owi_wind_direction)

s <- st_as_stars(s, curvilinear = list(X1 = owi_long, X2 = owi_lat))

plot(s, as_points = FALSE, axes = TRUE, breaks = "equal", border = NA)
```

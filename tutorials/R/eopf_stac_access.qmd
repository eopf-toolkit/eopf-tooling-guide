---
title: "How to for the EOPF Sample Service STAC catalog"
format:
  html:
    toc: true
    toc-depth: 3
    toc-location: left
    toc-expand: true
execute:
  cache: true
---

# Introduction

This tutorial will explore how to access the [EOPF Sample Service STAC catalog](https://stac.browser.user.eopf.eodc.eu/) programmatically using R. 

# Prerequisites

An R environment is required to follow this tutorial, with R version >= 4.1.0. We recommend using either [RStudio](https://posit.co/download/rstudio-desktop/) or [Positron](https://posit.co/products/ide/positron/) (or a cloud computing environment) and making use of [RStudio projects](https://support.posit.co/hc/en-us/articles/200526207-Using-RStudio-Projects) for a self-contained coding environment.

## Dependencies

The `rstatc` package is required to follow this tutorial. You can install it directly from CRAN:

```{r install}
#| eval: false
install.packages("rstac")
```

Then load the package into your environment:

```{r load}
#| cache: false
library(rstac)
```

# Exploring the EOPF Sample Service STAC catalog

# Setting up the API

To access the EOPF Sample Service STAC catalog in R, we need to give the URL of the STAC API source ([https://stac.core.eopf.eodc.eu/](https://stac.core.eopf.eodc.eu/)) using the function `stac()`.
 
The object `stac_source` is a query containing information used _to_ connect to the API, but it does not actually make any requests. To make requests to the API, we will always need to use `get_request()` or `put_request()`, as appropriate. Running `get_request()` on `stac_source` actually retrieves the catalogue:

```{r get-api}
stac_source <- stac("https://stac.core.eopf.eodc.eu/")

stac_source |>
  get_request()
```

# Collections

A STAC _Collection_ exists to relate similar data sets together through space, time, and shared metadata. Each Sentinel mission and the downstream analysis-ready data are examples of STAC Collections. To browse STAC Collections, the `collections()` function is used. We can see that there are 11 collections available in the API, as well as information 

```{r collections}
stac_collections <- stac_source |>
  collections() |>
  get_request()

stac_collections
```

The default printing of the `stac_collections()` object summarises what's been returned, but does not give all of the information. To see more about what's been returned, we can used `str()`.

```{r collections-obj-details}
stac_collections |>
  str(max.level = 1)
```

Here, we can see that there is an entry `"collections"` within `stac_collections`, which we access to return the collections themselves (using `head()` to only return a few). This shows additional details about each collection, such as the collection id, title, description, and additional fields in the collections.

```{r collections-details}
stac_collections[["collections"]] |>
  head(n = 3)
```

The Sentinel-2 Level-2A can be accessed by getting the first entry in `stac_collections()[["collections"]]`

```{r collections-single-index}
stac_collections[["collections"]][[1]]
```

However, the best way to access a specific collection is to search for it directly using the collection `id`. The `id`, "sentinel-2-l2a", is visible in the Collection output above. It is also accessible in the browsable STAC catalog of the EOPF Sentinel Zarr Samples Service, on the page for that collection ([https://stac.browser.user.eopf.eodc.eu/collections/sentinel-2-l2a](https://stac.browser.user.eopf.eodc.eu/collections/sentinel-2-l2a))

![Finding the collection ID in the STAC catalog](images/eopf-stac-access-collections-id.png)

(TODO -> consistent way of "highlighting" sections of pages)

The collection ID can be supplied directly in the `collections()` function. If we look at the query without getting the result, we can see that it has been formed using the `collection_id`, "sentinel-2-l2a", as a filter parameter.

```{r get-collection-by-id-query}
sentinel_2_l2a_query <- stac_source |>
  collections(collection_id = "sentinel-2-l2a")

sentinel_2_l2a_query
```

And that running `get_request()` will return the collection itself:

```{r get-collection-by-id}
sentinel_2_l2a_query |>
  get_request()
```

# Items

Within collections, there are _items_. Items are the building blocks for STAC. At their core, they are GeoJSON data, along with additional metadata which ensures data provenance is maintained and specific data attributes are captured. A single capture from a Sentinel mission is an example of a STAC item. To get an overview of items within a collection, the `items()` function is used. 

An important thing to note with `rstac` is that you cannot continue to build queries on top of ones that have already had their results returned (via `get_request()`). It may make sense for a typical workflow in R to "get" the collection, then to try to get the items from it, but this will produce an error:

```{r item-error}
#| error: true
sentinel_2_l2a_collection <- stac_source |>
  collections(collection_id = "sentinel-2-l2a") |>
  get_request()

sentinel_2_l2a_collection |>
  items()
```

If you see this error --- `"Invalid rstac_query value"` --- ensure that you are running `get_request()` at the very end of your query building functions. Using `items()` this way, we can see that it returns a summary of the collection's items:

```{r get-items}
sentinel_2_l2a_collection_items <- stac_source |>
  collections(collection_id = "sentinel-2-l2a") |>
  items() |>
  get_request()

sentinel_2_l2a_collection_items
```

The first 10 items are returned. This number can be changed via the `limit` argument in `items()`

```{r get-items-limit}
stac_source |>
  collections(collection_id = "sentinel-2-l2a") |>
  items(limit = 20) |>
  get_request()
```

## Item properties

We can look closer at individual items to see the metadata attached to them. Items are stores under `"features"`

```{r items-features}
sentinel_2_l2a_collection_items[["features"]] %>%
  head(n = 2)
```

And an individual item contains a lot of information, such as its bounding box:

```{r item-bbox}
sentinel_2_l2a_first_item <- sentinel_2_l2a_collection_items[["features"]][[1]]

sentinel_2_l2a_first_item[["bbox"]]
```

And many more additional properties:

With their properties under `"properties"` in an individual item.

```{r item-properties}
sentinel_2_l2a_first_item[["properties"]] %>%
  names()
```

TODO: link to this table (or include it here as well?) https://github.com/eopf-toolkit/eopf-tooling-guide/blob/EOPF-47/docs/tutorials/stac_zarr.md#eopf-and-stac-extensions to better explain item properties

For example, the EOPF instrument mode:

```{r item-properties}
sentinel_2_l2a_first_item[["properties"]][["eopf:instrument_mode"]]
```

For the rest of the tutorial, we will use a small helper function that accesses a given property for the _first_ item returned in a search.

```{r get-item-property}
get_first_item_property <- function(search_results, property) {
  search_results[["features"]][[1]][["properties"]][[property]]
}

sentinel_2_l2a_collection_items %>%
  get_first_item_property("eopf:instrument_mode")
```

## Searching for items

If the goal is to access data from a specific mission, it is best to _search_ within a collection's items, using some of the properties explored above. It's possible to search based on a number of criteria, including a bounding box, time frame, and other mission properties.

### Searching by a bounding box

To narrow down items based on a bounding box or time frame, the `stac_search()` function is used. The collection ID is provided in the `collections()` argument, and bounding box and time frame are `bbox` and `datetime`, respectively.

The bounding box values take the sequence of: minimum longitude, minimum latitude, maximum longitude, and maximum latitude, and their coordinate reference system is WGS84.

```{r search-items-bbox}
stac_source |>
  stac_search(
    collections = "sentinel-2-l2a",
    bbox = c(-47.02148, -17.35063, -42.53906, -12.98314)
  ) |>
  get_request()
```

This does -- again by default -- return the first 10 items, but the number returned can be increased via the `limit` argument in `stac_search()`.

### Searching by a time frame

When searching for a specific time frame, items that have a datetime property that _intersects_ with the given time frame will be returned. It's therefore best to search for a closed or open interval, rather than a specific date and time (which might be difficult to match exactly to an item's time!). The date-time must be given in RFC 3339 format.

To search for a closed interval, separate two date-times by a "/", e.g. "2024-12-01T01:00:00Z/2024-12-01T05:00:00Z":

```{r search-items-datetime-closed-interval}
matching_timeframe_items <- stac_source |>
  stac_search(
    collections = "sentinel-2-l2a",
    datetime = "2024-12-01T01:00:00Z/2024-12-01T05:00:00Z"
  ) |>
  get_request()

matching_timeframe_items
```

We can access the matching item's `datetime` property to see that it falls within the specified interval:

```{r search-items-datetime-closed-interval-examine-property}
matching_timeframe_items %>%
  get_first_item_property("datetime")
```

To search by an open interval, ".." is used to indicate the open end, e.g. "../2024-01-01T23:00:00Z" representing prior to that date-time, and "2024-01-01T23:00:00Z/.." representing after it:

```{r search-items-datetime-open-interval}
stac_source |>
  stac_search(
    collections = "sentinel-2-l2a",
    datetime = "2025-01-01T23:00:00Z/.."
  ) |>
  get_request()
```

### Searching by other item properties

As shown above, there are a number of other properties attached to STAC items. We can also search using these properties. The `stac_search()` function is limited to properties like bounding box and time frame, so instead we use `ext_filter()`. This is a function that makes use of the Common Query Language (CQL2) filter extension, and allows us to do more complicated searching and querying using SQL-like language.

To search for items whose platform is "sentinel-2b", for example, we use `==` to indicate equality:

```{r search-items-extfilter}
sentinel_2b_platform_results <- stac_source %>%
  stac_search(collections = "sentinel-2-l2a") %>%
  ext_filter(platform == "sentinel-2b") %>%
  get_request()

sentinel_2b_platform_results

sentinel_2b_platform_results %>%
  get_first_item_property("platform")
```

If the search value is contained in another variable, the value must be escaped in the search by using double curly braces:

```{r search-items-extfilter-variable}
search_platform <- "sentinel-2b"

sentinel_2b_platform_results <- stac_source %>%
  stac_search(collections = "sentinel-2-l2a") %>%
  ext_filter(platform == {{ search_platform }}) %>%
  get_request()

sentinel_2b_platform_results %>%
  get_first_item_property("platform")
```

Note also that there is no `limit` argument in `ext_filter()`. To limit the number of items returned, the limit is supplied in `stac_search()` beforehand, since these search functions build upon one another:

```{r search-items-extfilter-limit}
stac_source %>%
  stac_search(collections = "sentinel-2-l2a", limit = 1) %>%
  ext_filter(platform == {{ search_platform }}) %>%
  get_request()
```

# TODO ------

To search for items whose instrument contains "msi", we can use the `%like%` operator:

```{r}
stac_source %>%
  stac_search(collections = "sentinel-2-l2a") %>%
  ext_filter(instruments %like% "%msi%") %>%
  get_request() %>%
  get_first_item_property("instruments")
```

# TODO ------

And to search for items with cloud cover of less than 40, we can use `<=`"


```{r search-items-extfilter-cloudcover}
stac_source %>%
  stac_search(collections = "sentinel-2-l2a") %>%
  ext_filter(`eo:cloud_cover` <= 40) |>
  get_request() %>%
  get_first_item_property("eo:cloud_cover")
```

The [documentation for `ext_filter()`](https://brazil-data-cube.github.io/rstac/reference/ext_filter.html#details) contains information on how to construct many more filters than we've shown here.

### Combining filter criteria

Finally, you can combine many filter criteria by supplying them together. We have already seen how to combine multiple criteria (collection ID and bounding box, for example) in `stac_search()`, by using the named arguments. We can also filter by bounding box and datetime in the sameway. Meanwhile, multiple criteria in `ext_filter()` are separated by `&&`:

```{r search-items-multiple-criteria}
multiple_criteria_items <- stac_source %>%
  stac_search(
    collections = "sentinel-2-l2a",
    bbox = c(-47.02148, -17.35063, -42.53906, -12.98314),
    datetime = "../2025-01-01T23:00:00Z"
  ) %>%
  ext_filter(
    platform == "sentinel-2a" &&
    `eo:cloud_cover` <= 40
  ) %>%
  get_request()

multiple_criteria_items %>%
  get_first_item_property("datetime")

multiple_criteria_items %>%
  get_first_item_property("platform")

multiple_criteria_items %>%
  get_first_item_property("eo:cloud_cover")
```

---

# WIP after this

```{r eval = FALSE}
# Additional filters: instrument, platform
# stac_search does not support all filters -> we can also use `ext_filter()`
stac_source |>
  ext_filter(
    collection == "sentinel-2-l2a" && `eo:cloud_cover` <= 10
  ) |>
  get_request()

# This isn't working:
x <- stac_source |>
  ext_filter(
    collection == "sentinel-2-l2a" && instruments == "msi"
  ) |>
  get_request()

# I wonder if it's some sort of case sensitivity etc?
x

# Combining filters
# bbox and datetime
stac_source |>
  stac_search(
    collections = "sentinel-2-l2a",
    bbox = c(-47.02148, -17.35063, -42.53906, -12.98314),
    datetime = "2024-01-01T00:00:00Z/2024-01-02T00:00:00Z"
  ) |>
  get_request()

# bbox and cloud coverage -> combining stac_search() and ext_filter()
stac_source |>
  stac_search(
    collections = "sentinel-2-l2a",
    bbox = c(-47.02148, -17.35063, -42.53906, -12.98314)
  ) |>
  ext_filter(`eo:cloud_cover` <= 40) |>
  get_request()
```

### Combining search criteria

```{r}
# Access a specific item(s) by ID

# (ID is available from the browser, click "Source" and copy it)
# https://stac.browser.user.eopf.eodc.eu/collections/sentinel-2-l2a/items/S2A_MSIL2A_20250517T085541_N0511_R064_T35QKA_20250517T112203?.language=en
example_item <- stac_source |>
  stac_search(
    collections = "sentinel-2-l2a",
    ids = "S2A_MSIL2A_20250517T085541_N0511_R064_T35QKA_20250517T112203"
  ) |>
  get_request()

example_item
```

# Assets

```{r}
# List the assets in an item
example_item |>
  items_assets()
```

```{r}
# Select specific assets
example_item |>
  assets_select(asset_names = "AOT_10m")
```

```{r}
# See its URL
asset_url <- example_item |>
  assets_select(asset_names = "AOT_10m") |>
  assets_url()

asset_url
```

```{r}
# The "product" asset is what will be used in the Zarr tutorial
example_item |>
  assets_select(asset_names = "product") |>
  assets_url()
```


```{r}
# In theory... we can use `items_matched()` to see how many match in a search:
stac_source |>
  stac_search(
    collections = "sentinel-2-l2a",
    bbox = c(-47.02148, -17.35063, -42.53906, -12.98314)
  ) |>
  get_request() |>
  items_matched()
# But: returns an integer value if the STAC web server does support this extension. Otherwise returns NULL.
# Not supported here
```
